/*
Hypatia: A realtime malware scanner for Android
Copyright (c) 2017-2018 Divested Computing Group

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
package com.rhul.fyp.malwarepoc.hypatia;

import android.app.Activity;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.content.Context;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Environment;
import android.os.SystemClock;
import android.widget.TextView;

import androidx.core.app.NotificationCompat;

import com.rhul.fyp.malwarepoc.R;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.text.NumberFormat;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.ConcurrentSkipListSet;

class MalwareScanner extends AsyncTask<HashSet<File>, Object, String> {

    private final Context context;
    private TextView logOutput = null;
    private boolean userFacing = false;
    private NotificationManager notificationManager = null;
    private long scanStartTime = 0;
    private final HashMap<File, String> fileHashesMD5 = new HashMap<>();
    private final HashMap<File, String> fileHashesSHA1 = new HashMap<>();
    private final HashMap<File, String> fileHashesSHA256 = new HashMap<>();
    public boolean running = false;

    public MalwareScanner(Activity activity, Context context, boolean userFacing) {
        this.context = context;
        this.userFacing = userFacing;
        if (activity != null) {
            logOutput = activity.findViewById(R.id.txtLogOutput);
        } else {
            notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                NotificationChannel detectionChannel = new NotificationChannel("DETECTION", context.getString(R.string.lblNotificationMalwareDetectionTitle), NotificationManager.IMPORTANCE_HIGH);
                detectionChannel.setDescription(context.getString(R.string.lblNotificationMalwareDetectionDescription));
                notificationManager.createNotificationChannel(detectionChannel);
            }
        }
    }

    private void logResult(String result, boolean userFacingOnly) {
        if (userFacing) {
            logOutput.append(result);
            if (!(result.length() <= 3)) {
                logOutput.append("\n");
            }
        } else if (!userFacingOnly) {
            String[] malwareDetect = result.split(" in ");
            NotificationCompat.Builder mBuilder =
                    new NotificationCompat.Builder(context)
                            .setSmallIcon(R.drawable.ic_notification)
                            .setContentTitle(context.getText(R.string.lblNotificationRealtimeDetection) + " " + malwareDetect[0])
                            .setContentText(malwareDetect[1])
                            .setPriority(Notification.PRIORITY_MAX)
                            .setDefaults(Notification.DEFAULT_VIBRATE);
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                mBuilder.setVisibility(NotificationCompat.VISIBILITY_SECRET);
            }
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                mBuilder.setChannelId("DETECTION");
            }
            notificationManager.notify(new Random().nextInt(), mBuilder.build());
        }
    }

    @Override
    protected final void onPreExecute() {
        scanStartTime = SystemClock.elapsedRealtime();
        logResult(context.getString(R.string.main_starting_scan), true);
    }

    @Override
    protected final String doInBackground(HashSet<File>[] filesToScan) {
        running = true;
        ConcurrentSkipListSet<File> filesToScanReal = new ConcurrentSkipListSet<>(); //TODO: Reduce this?
        for (Set<File> fileArray : filesToScan) {
            for (File file : fileArray) {
                filesToScanReal.addAll(Utils.getFilesRecursive(file)); //TODO: Inline this, hash files as they are found
            }
        }
        filesToScan = null;

        //Pre
        fileHashesMD5.clear();
        fileHashesSHA1.clear();
        fileHashesSHA256.clear();

        publishProgress("\t" + context.getString(R.string.main_files_pending_scan, NumberFormat.getInstance().format(filesToScanReal.size()) + "") + "\n", true);

        Database.loadDatabase(context, false, Database.signatureDatabases);
        int delayCount = 0;
        if (Database.areDatabasesAvailable()) {
            while (!Database.isDatabaseLoaded() && delayCount <= 90) {
                try {
                    Thread.sleep(1000);
                    delayCount++;
                    if ((delayCount % 15) == 0) {
                        publishProgress("\t" + context.getString(R.string.main_database_loading), true);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        if (Database.isDatabaseLoaded()) {
            publishProgress("\t" + context.getString(R.string.main_database_loaded, NumberFormat.getInstance().format(Database.getSignatureCount()) + "") + "\n", true);

            //Get file hashes
            publishProgress("\t" + context.getString(R.string.main_hashing_files), true);
            publishProgress("\t", true);
            int fileScannedCount = 0;
            int percentIncrement = (filesToScanReal.size() / 20);
            if (percentIncrement < 1) { //Prevent divide by zero
                percentIncrement = 1;
            }
            String spinnerCur = " ~ ";
            long totalBytesHashed = 0;
            long hashStartTime = SystemClock.elapsedRealtime();
            for (File file : filesToScanReal) {
                if (this.isCancelled()) { //Allow quicker cancels
                    //publishProgress("\t" + context.getString(R.string.main_cancelled_scan), true);
                    running = false;
                    return null;
                }
                totalBytesHashed += file.length();
                getFileHashes(file);
                filesToScanReal.remove(file);
                fileScannedCount++;
                if ((fileScannedCount % percentIncrement) == 0) {
                    publishProgress(spinnerCur, true);
                    if (spinnerCur.equals(" = ")) {
                        spinnerCur = " ~ ";
                    } else {
                        spinnerCur = " = ";
                    }
                }
            }
            filesToScanReal.clear();
            publishProgress(" !\n\t" + context.getString(R.string.main_hashing_done) + "\n", true);

            //Check the hashes by passing the list of hashed files as well as the database and the hash type.
            checkSignature("MD5", fileHashesMD5, Database.signaturesMD5);
            checkSignature("SHA-1", fileHashesSHA1, Database.signaturesSHA1);
            checkSignature("SHA-256", fileHashesSHA256, Database.signaturesSHA256);

            //Post
            fileHashesMD5.clear();
            fileHashesSHA1.clear();
            fileHashesSHA256.clear();
            Utils.FILES_SCANNED.getAndAdd(fileScannedCount);
            if (userFacing || Utils.FILES_SCANNED.get() % 40 == 0) {
                System.gc(); //GC can be expensive, don't run it too often.
            }
            if (userFacing) {
                long secondsSpent = ((SystemClock.elapsedRealtime() - scanStartTime) / 1000L);
                long secondsSpentHashing = ((SystemClock.elapsedRealtime() - hashStartTime) / 1000L);
                long MBS = totalBytesHashed / 1000 / 1000 / secondsSpentHashing;
                publishProgress(context.getString(R.string.main_scanning_done, secondsSpent + "", MBS + "") + "\n\n\n\n", true);
            }
        } else {
            publishProgress("\t" + context.getString(R.string.main_no_database_available), true);
            running = false;
        }
        running = false;
        return null;
    }

    @Override
    protected final void onProgressUpdate(Object... objects) {
        logResult((String) objects[0], (boolean) objects[1]);
    }

    /**
     * Passes file hashes and signature database in order to compare files with the hashes of malware infected files.
     * @param hashType
     * @param signaturesToCheck
     * @param signatureDatabase
     */
    private void checkSignature(String hashType, HashMap<File, String> signaturesToCheck, HashMap<String, String> signatureDatabase) {
        if (signatureDatabase.size() > 0) {
            for (Map.Entry<File, String> file : signaturesToCheck.entrySet()) {
                if (signatureDatabase.containsKey(file.getValue())) {
                    String result = signatureDatabase.get(file.getValue());
                    publishProgress(result + " in " + file.getKey().toString().replaceAll(Environment.getExternalStorageDirectory().toString(), "~"), false);
                }
            }
            publishProgress("\t" + context.getString(R.string.main_hash_scan_done, hashType) + "\n", true);
        } else {
            publishProgress("\t" + context.getString(R.string.main_no_database_available) + "\n", true);
        }
    }

    /**
     * Uses MessageDigest Android Class to Hash given file using multiple algorithms and then stores hashes into a database.
     * @param file
     */
    private void getFileHashes(File file) {
        try {
            InputStream fis = new FileInputStream(file);

            byte[] buffer = new byte[4096];
            int numRead;

            MessageDigest digestMD5 = MessageDigest.getInstance("MD5");
            MessageDigest digestSHA1 = MessageDigest.getInstance("SHA-1");
            MessageDigest digestSHA256 = MessageDigest.getInstance("SHA-256");

            do {
                numRead = fis.read(buffer);
                if (numRead > 0) {
                    digestMD5.update(buffer, 0, numRead);
                    digestSHA1.update(buffer, 0, numRead);
                    digestSHA256.update(buffer, 0, numRead);
                }
            } while (numRead != -1);

            fis.close();

            fileHashesMD5.put(file, String.format("%032x", new BigInteger(1, digestMD5.digest())).substring(0, Utils.MAX_HASH_LENGTH));
            fileHashesSHA1.put(file, String.format("%032x", new BigInteger(1, digestSHA1.digest())).substring(0, Utils.MAX_HASH_LENGTH));
            fileHashesSHA256.put(file, String.format("%064x", new BigInteger(1, digestSHA256.digest())).substring(0, Utils.MAX_HASH_LENGTH));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
